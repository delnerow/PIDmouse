function [xx, yy] = path_to_line(path,ordens, cellSize,ax)
      % Gera trajetória contínua suave a partir do path e ordens (frente, giraDir, giraEsq)

    pos = cell_to_world(path, cellSize);
    N = size(path,1);

    xx = [];
    yy = [];

    i = 1;
    p0 = pos(i,:);
    xx = [xx linspace(p0(1), p0(1), 10)];
    yy = [yy linspace(p0(2), p0(2)-cellSize/2, 10)];
    while i <= length(ordens)-2
        o2 = ordens(i+1);
        o3 = ordens(i+2);
        if o2~=0 && o3==o2
            % Caso do U-turn, duas curvas no mesmo sentido
            p0 = pos(i,:);
            p1 = pos(i+1,:);
            p2 = pos(i+2,:);
           
            [x_arc, y_arc] = interpolar_arco(p0, p1, p2, cellSize);
            xx = [xx x_arc];
            yy = [yy y_arc];
        
            i = i + 2;
    
        elseif  o2~=0
            % giro  ⇒ diagonal
            p0 = pos(i,:);
            p1 = pos(i+1,:);
            p2 = pos(i+2,:);
            [x_arc, y_arc] = interpolar_diagonal(p0, p1, p2, cellSize);
            xx = [xx x_arc];
            yy = [yy y_arc];
            i = i + 2; % avança 2, pois o arco cobre 3 células

        else
            % caso simples: segmento de reta
            p0 = pos(i,:);
            p1 = pos(i+1,:);
            v= p1-p0;
            p0
            xx = [xx linspace(p0(1), p1(1), 10)];
            yy = [yy linspace(p0(2), p1(2), 10)];
            i = i + 1;
        end
    end

    % Último trecho reto (caso o loop não vá até o fim)
    for j = i:N-1
        p0 = pos(j,:);
        p1 = pos(j+1,:);
        xx = [xx linspace(p0(1), p1(1), 10)];
        yy = [yy linspace(p0(2), p1(2), 10)];
    end

    % Plot final
    plot(ax, xx, yy, 'm-', 'LineWidth', 2);
end

function pos = cell_to_world(cells, cellSize)
    % Transforma [linha, coluna] → [x, y] no mundo real (centro da célula)
    x = (cells(:,2) - 0.5) * cellSize;
    y = (16-cells(:,1) + 0.5) * cellSize;
    pos = [x, y];
end
function [xx, yy] = interpolar_arco(p0,p1,p2,cellSize)
 raio = cellSize / 2;
            
            centro = p1+ (p2-p1)/2+(p0-p1)/2;
            v = (p1-p0)/2;

            v1 = p1 - p0;  % vetor da entrada
            v2 = p2 - p1;  % vetor da saída
            z = v1(1)*v2(2) - v1(2)*v2(1);  % produto vetorial 2D (z-component)

            theta1 = atan2(p0(2)+v(2)-centro(2), p0(1)+v(1)-centro(1));
            theta2 = atan2(p2(2)-v(2)-centro(2), p2(1)-v(1)-centro(1));
            
            % gerar arco suave de 180°
            % decidir sentido (horário ou anti)
             if z > 0
            % anti-horário
            if theta2 < theta1
                theta2 = theta2 + 2*pi;
            end
            theta = linspace(theta1, theta2, 20);
            else
                % horário
                if theta2 > theta1
                    theta2 = theta2 - 2*pi;
                end
                theta = linspace(theta1, theta2, 20);
            end
            
            xx = centro(1) + raio * cos(theta);
            yy = centro(2) + raio * sin(theta);
end


function [xx, yy] = interpolar_diagonal(p0,p1,p2,cellSize)

    % ângulos de início/fim com base na direção relativa
    % Direção vetorial para calcular centro do arco
    dirvec = [0 1; 1 0; 0 -1; -1 0];
    d0 = find(all(dirvec==p1-p0,2));

    v = (p2 - p0)/2;
    if(d0==1) p=[p0(1),p0(2)+cellSize/2];
    elseif(d0==3) p=[p0(1),p0(2)-cellSize/2];
    elseif(d0==2) p=[p0(1)+cellSize/2,p0(2)];
    elseif(d0==4) p=[p0(1)-cellSize/2,p0(2)];
    end
    pf=p+v;
    xx =  linspace(p(1), pf(1), 10);
    yy = linspace(p(2), pf(2), 10);
end