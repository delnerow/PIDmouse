classdef HybridController
    properties
        % Gains PID lateral
        Kp_lat = 0;
        Ki_lat = 0;
        Kd_lat = 0;

        % Gains PID angular
        Kp_ang = 2;
        Ki_ang = 0;
        Kd_ang = 0;

        % Estado erros integrados e últimos erros
        integral_lat = 0;
        last_error_lat = 0;

        integral_ang = 0;
        last_error_ang = 0;
        idx_last = 1;
        lookahead = 0.5; % distância lookahead (mm ou cm)
    end

    methods
        function obj = HybridController()
            if nargin > 0
                obj.lookahead = lookahead;
            end
        end

        function [v, omega, obj] = update(obj, x_r, y_r, theta_r, xx, yy, dt)
            % 1. Pure Pursuit ponto alvo
            
            distancias = sqrt((xx - x_r).^2 + (yy - y_r).^2);
            N = length(xx);
idxs = obj.idx_last:N;

vecs = [xx(idxs) - x_r; yy(idxs) - y_r];
distancias = sqrt(vecs(1,:).^2 + vecs(2,:).^2);
dir_r = [cos(theta_r); sin(theta_r)];
dot_prods = dir_r' * vecs;

idx_valid = find((distancias > obj.lookahead) & (dot_prods > 0));

if isempty(idx_valid)
    idx_target = idxs(end); % último ponto possível
else
    idx_target = idxs(idx_valid(1));
end

% Atualiza idx_last
obj.idx_last = idx_target;
            x_target = xx(idx_target);
            y_target = yy(idx_target);
            % Vetor para ponto alvo
            vec_target = [x_target - x_r, y_target - y_r];
            alpha = (atan2(y_target - y_r, x_target - x_r) - theta_r);
            alpha = atan2(sin(alpha), cos(alpha)); % normaliza
            fprintf("target, alpha : %.3f , deg: %.1f\n", rad2deg(atan2(y_target- y_r, x_target- x_r)), rad2deg(alpha));
            % 2. Erro lateral (aproximado)
            % Vetor tangente da curva no ponto alvo
            if idx_target == 1
                tangent = [xx(2) - xx(1), yy(2) - yy(1)];
            elseif idx_target == length(xx)
                tangent = [xx(end) - xx(end-1), yy(end) - yy(end-1)];
            else
                tangent = [xx(idx_target+1) - xx(idx_target-1), yy(idx_target+1) - yy(idx_target-1)];
            end
            
            norm_tan = norm(tangent);
            if norm_tan < 1e-6
                tangent = [1, 0]; % vetor padrão para evitar NaN
            else
                tangent = tangent / norm_tan;
            end

            % Vetor do robô para ponto alvo
            vec_r = [x_r - xx(idx_target), y_r - yy(idx_target)];
            % Erro lateral é projeção ortogonal (produto vetorial simples 2D)
            error_lat = vec_r(1)*tangent(2) - vec_r(2)*tangent(1);
            fprintf("lat : %.3f \n", error_lat);
            % 3. Erro angular é alpha (diferença de ângulo para o ponto alvo)
            error_ang = alpha;

            % 4. PID lateral
            obj.integral_lat = obj.integral_lat + error_lat * dt;
            deriv_lat = (error_lat - obj.last_error_lat) / dt;
            obj.last_error_lat = error_lat;
            corr_lat = obj.Kp_lat*error_lat + obj.Ki_lat*obj.integral_lat + obj.Kd_lat*deriv_lat;

            % 5. PID angular
            obj.integral_ang = obj.integral_ang + error_ang * dt;
            deriv_ang = (error_ang - obj.last_error_ang) / dt;
            obj.last_error_ang = error_ang;
            corr_ang = obj.Kp_ang*error_ang + obj.Ki_ang*obj.integral_ang + obj.Kd_ang*deriv_ang;

            % 6. Combinando correções
            v = 0.2; % velocidade linear constante
            omega = corr_ang + corr_lat;
            max_w = pi; % rad/s
            omega = max(min(omega, max_w), -max_w);
            % Reduzir velocidade em curvas fechadas
            if abs(error_ang) > pi/6
                v = v * 0.5;
            end
            fprintf("Velocidades comandadas: \n v: %f \n w: %f \n",v,omega);
        end
        
    end
    
end
