function micromouse(maze)
    % Maze no formato bitfield.
    % Wall bits: 0x08=West, 0x01=South, 0x02=East, 0x04=North

    % Configura√ß√µes da simua√ß√£o, par√¢metros e plots
    config=obterConfig();

    maze_grid=load_maze_bin("mazes/"+maze+".maz");

    % NxN, dimens√£o do labirinto
    N=size(maze_grid,1);
    [start,goal,mouse]=obterDimensoes();
    
    % Obter paredes pelo binario, ela os sensores detectam
    paredes = obterParedes(maze_grid);

    % Paredes como segmentos
    paredesHV =obterSegmentosDeHV(paredes);

    % Polyshape espec√≠fica pra detectar colis√£o com mouse
    wall_polys = gerarParedesPolyshape(paredes);

    % Fazendo floofill no mapa inteiro
    floodval = flood_fill_micromouse(maze_grid, goal, 0, start);
    
    % Plotando o mapa
    ax = gca; visualize_maze_bitfield(wall_polys,N ,goal, floodval,ax);

    % Melhor caminho at√© o goal, com celulas e comandos/direcoes delas
    [path,ordens] = stack_caminho(floodval,maze_grid,start);
    linha = path_to_line(path,ordens, 1,config.path, ax, config.quinas); % Stack de celulas vira curva
    
    % Criar texto para o cron√¥metro
    timer_text = text(ax, 1, 0.98, 'Tempo: 0.00s', 'Units', 'normalized', ...
        'FontSize', 12, 'FontWeight', 'bold', 'Color', 'red', ...
        'BackgroundColor', 'white', 'EdgeColor', 'black');
    
    % Criar texto para a velocidade
    vel_text = text(ax, 1, 0.8, 'Velocidade: 0.00 cel/s', 'Units', 'normalized', ...
        'FontSize', 12, 'FontWeight', 'bold', 'Color', 'blue', ...
        'BackgroundColor', 'white', 'EdgeColor', 'black');

    % Plotando mouse pela primeira vez
    % Polyshape do mouse, para  detectar colis√£o com parede
    coord.x=mouse.x_real; coord.y=mouse.y_real; coord.theta=mouse.theta_real;
    poly_mouse = mousePolyshape(coord, mouse.side);
    draw_mouse = plot(ax,poly_mouse, 'FaceColor', 'blue', 'FaceAlpha', 0.4); 
    % Plotar raios do sensor
    raios = plotaSensores(ax, mouse.x_real, mouse.y_real);

    % Inicializa controladores
    ctrl = PIDlookahead();
    giro = PIDgiro();
    
    % Vetor que da boost ao robo quando identifica linha reta longa
    consecutivos = obterSequenciaOrdens(ordens); 
    trecho=1;           % Em qual trecho de consecutivos esta
    cellPercorridas=0;  % quantas celulas do trecho total (linha) percorreu
    
    
    % colidiu ou n√£o
    % colidiu = false;

    % Main Loop
    dt=config.passo;
    passo=0; %para ver frames e tempo da simua√ß√£o
    tic; 
    vel_ref = [];
    vel_real = [];
    time_vec = [];
    lookds=[];
    boosts=[];
    giroL_ref=[];
    giroL_real=[];
    w_ref=[];
    w_real=[];
    
    % Para armazenar o rastro do mouse
    rastro_posicoes = [];

    while ~isequal(mouse.cell, goal)
        % As coordenadas do mouse, usando odometria ou posi√ß√£o real
        if strcmp(config.encoder,'true')
            coord.x=mouse.x_encoder;
            coord.y=mouse.y_encoder;
            coord.theta=mouse.theta_real;
        else
            coord.x=mouse.x_real;
            coord.y=mouse.y_real;
            coord.theta=mouse.theta_real;
        end
        
        % Boost de velocidade atual h√° 3 tipos diferentes: gauss, rampa e nulo (boost=1)
        if trecho> length(consecutivos), trecho = trecho-1; end
        boost = obterBoost(consecutivos(trecho),cellPercorridas,config.boost_tipo);

        % Obtendo leitura dos sensores
        sensores= obterInfravermelho(coord, paredesHV);

        % Chamando o PID
        [vR,vL, ctrl] = ctrl.update(coord,mouse, linha, dt, sensores, boost, config.lookahead);
        
        % Encoder
        [mouse.encoder_L,mouse.encoder_R,mouse.encoder_L_prev,mouse.encoder_R_prev, mouse.wL_encoder,mouse.wR_encoder] = encoder_simulado(mouse,dt);
      
        % Obtendo velocidades angulares das rodas
        [mouse.wL_real, mouse.wR_real, giro]= giro.update(mouse, vR,vL,dt);
        
        % atualizando o Mickey
        mouse.vR_real=mouse.wR_real*mouse.wheel;
        mouse.vL_real=mouse.wL_real*mouse.wheel;

        mouse.vR_encoder=mouse.wR_encoder*mouse.wheel;
        mouse.vL_encoder=mouse.wL_encoder*mouse.wheel;
        % Mexendo o mouse
        

        
        if strcmp(config.encoder,'true')
            % --- CINEM√ÅTICA DIFERENCIAL ENCODER (ODOMETRIA) ---
            v_media_encoder = (mouse.vR_encoder + mouse.vL_encoder) / 2;
            mouse.v_media=v_media_encoder;
            w_mouse_encoder = (mouse.vR_encoder - mouse.vL_encoder) / mouse.L;
            
            % Usar Runge-Kutta de 4¬™ ordem para integra√ß√£o mais precisa
            k1_x = v_media_encoder * cos(mouse.theta_encoder);
            k1_y = v_media_encoder * sin(mouse.theta_encoder);
            k1_theta = w_mouse_encoder;
            
            k2_x = v_media_encoder * cos(mouse.theta_encoder + k1_theta * dt/2);
            k2_y = v_media_encoder * sin(mouse.theta_encoder + k1_theta * dt/2);
            k2_theta = w_mouse_encoder;
            
            k3_x = v_media_encoder * cos(mouse.theta_encoder + k2_theta * dt/2);
            k3_y = v_media_encoder * sin(mouse.theta_encoder + k2_theta * dt/2);
            k3_theta = w_mouse_encoder;
            
            k4_x = v_media_encoder * cos(mouse.theta_encoder + k3_theta * dt);
            k4_y = v_media_encoder * sin(mouse.theta_encoder + k3_theta * dt);
            k4_theta = w_mouse_encoder;
            
            % Atualizar posi√ß√£o e orienta√ß√£o usando apenas odometria
            mouse.x_encoder = mouse.x_encoder + (k1_x + 2*k2_x + 2*k3_x + k4_x) * dt / 6;
            mouse.y_encoder = mouse.y_encoder + (k1_y + 2*k2_y + 2*k3_y + k4_y) * dt / 6;
            mouse.theta_encoder = mouse.theta_encoder + (k1_theta + 2*k2_theta + 2*k3_theta + k4_theta) * dt / 6;
            mouse.theta_encoder = atan2(sin(mouse.theta_encoder), cos(mouse.theta_encoder));
        else
            % --- CINEM√ÅTICA DIFERENCIAL REAL ---
            v_media = (mouse.vR_real + mouse.vL_real) / 2;
            mouse.v_media=v_media;
            w_mouse = (mouse.vR_real - mouse.vL_real) / mouse.L;
            mouse.x_real = mouse.x_real + v_media * cos(mouse.theta_real) * dt;
            mouse.y_real = mouse.y_real + v_media * sin(mouse.theta_real) * dt;
            mouse.theta_real = mouse.theta_real + w_mouse * dt;
            mouse.theta_real = atan2(sin(mouse.theta_real), cos(mouse.theta_real));
        end
        curCell = returnCell(N,mouse);
        if ~isequal(curCell,mouse.cell), cellPercorridas=cellPercorridas+1;end
        if(cellPercorridas == consecutivos(trecho)), trecho = trecho+1;end
        mouse.cell=curCell;
        
        % tempos de frame
        passo=passo+1;
        if mod(passo, 1) == 0
            % Visualize mouse
            if strcmp(config.animar,'true')
                poly_mouse = mousePolyshape(coord, mouse.side);
                draw_mouse=visualize_mouse(ax,poly_mouse,draw_mouse);
                % Reta do sensor 
                visualize_ray(coord,paredesHV,raios);
                % Atualizar cron√¥metro
                set(timer_text, 'String', sprintf('Tempo: %.2fs', passo*dt));
                
                % Atualizar velocidade m√©dia
                set(vel_text, 'String', sprintf('Velocidade: %.2f cel/s', mouse.v_media));
            end
            % Debug
            %fprintf("(x) e (y) e(theta) :%f,%f  %f \n",mouse.x_real,mouse.y_real,mouse.theta_real/pi*180);
            %fprintf("ENCODER: (x) e (y) e(theta) :%f,%f  %f \n",mouse.x_encoder,mouse.y_encoder,mouse.theta_encoder/pi*180);
            %fprintf("Trecho, percorridas, boost : %.3f , %.1f, %f\n", trecho,cellPercorridas, boost);
            %fprintf("ENCODER: (v) e (omega) :%f,%f  \n",(mouse.vR_encoder  + mouse.vL_encoder ) / 2, (mouse.vR_encoder  - mouse.vL_encoder ) / mouse.L);
            %fprintf("Real: (v) e (omega) :%f,%f  \n",(mouse.vR_real  + mouse.vL_real ) / 2, (mouse.vR_real  - mouse.vL_real ) / mouse.L);
            %fprintf("Giros comandados: \n R: %f \n L: %f \n",mouse.wR_real,mouse.wL_real);
            %fprintf("Velocidades comandadas: \n v: %f \n w: %f \n",(vR + vL) / 2,(vR-vL)/(2*mouse.L));
            %fprintf("Leitura paredes: f %.3f, d %.3f e %.3f\n", dist_f,dist_dir,dist_esq);
        end

        vel_ref(end+1) = (vR + vL) / 2; % Reference velocity (commanded)
        vel_real(end+1) = (mouse.vR_real + mouse.vL_real) / 2; % Real velocity
        time_vec(end+1) = passo * dt;
        lookds(end+1)=ctrl.lookahead;
        boosts(end+1)=boost;
        giroL_ref(end+1)= vL/mouse.wheel;
        giroL_real(end+1)= mouse.wL_real;
        w_ref(end+1)=(vR - vL) / mouse.L;
        w_real(end+1)=(mouse.vR_real - mouse.vL_real) / mouse.L;

        
        % Armazenar posi√ß√£o e orienta√ß√£o para o rastro
        rastro_posicoes(end+1, :) = [coord.x, coord.y];

        %for i = 1:length(wall_polys)
        %    if overlaps(poly_mouse, wall_polys(i))
        %        colidiu = true;
        %        break;
        %    end
        %end
        
        %if colidiu
        %    disp("üü• Colis√£o detectada! Encerrando simula√ß√£o...");
        %return; 
        %end
    end

    % Final
    title(sprintf('Tempo para simula√ß√£o: %.2f segundos', toc));
    set(timer_text, 'String', sprintf('Tempo: %.2fs', passo*dt));
    
    % Atualizar velocidade final
    set(vel_text, 'String', sprintf('Velocidade: %.2f cel/s', mouse.v_media));
    poly_mouse = mousePolyshape(coord, mouse.side);
    visualize_mouse(ax,poly_mouse,draw_mouse);
    
    % Plotar o rastro do mouse
    if strcmp(config.rastro,'true')
        plotRastro(ax, rastro_posicoes);
    end
    if strcmp(config.graficos,'true')

        %  Velocidades - referencia e real
        figure;
        plot(time_vec, vel_ref, 'b-', 'DisplayName', 'Velocidade refenrencia');
        hold on;
        plot(time_vec, vel_real, 'r-', 'DisplayName', 'Velocidade real');
        xlabel('Tempo (s)');
        ylabel('Velocidade (x18cm/s)');
        legend;
        title('Velocidades Referencia vs Real no tempo');
        
        hold off;

        % Boosts e lookahead 
        figure;
        plot(time_vec, lookds, 'b-', 'DisplayName', 'Lookahead');
        hold on;
        plot(time_vec, boosts, 'r-', 'DisplayName', 'Boosts');
        xlabel('Time (s)');
        ylabel('Valor');
        legend;
        title('Lookahead vs Boosts no tempo');
        
        hold off;

        % Omega 
        figure;
        plot(time_vec, w_ref, 'b-', 'DisplayName', 'Omega referencia');
        hold on;
        plot(time_vec, w_real, 'r-', 'DisplayName', 'Omega real');
        xlabel('Time (s)');
        ylabel('Valor');
        legend;
        title('Omega referencia vs real no tempo');
        hold off;

        % Giro de uma roda 
        figure;
        plot(time_vec, giroL_ref, 'b-', 'DisplayName', 'Giro referencia');
        hold on;
        plot(time_vec, giroL_real, 'r-', 'DisplayName', 'Giro real');
        xlabel('Time (s)');
        ylabel('Valor');
        legend;
        title('Giro referencia vs real roda esquerda no tempo');
        
        hold off;
    end

end






