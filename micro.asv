% Micromouse Maze Simulation with Flood Fill Integration
% Uses bitfield maze encoding, flood fill logic, and dynamic wall checking.
function micro()
    close all; clc;
    % Maze in bitfield format (1D, row-major order, uint8).
    % Wall bits: 0x08=West, 0x01=South, 0x02=East, 0x04=North
    
    maze_grid=load_maze_bin("mazes/yama7.maz");

    N=size(maze_grid,1);
    [start,goal,mouse]=obterDimensoes();
    
    % Obter paredes do binario, plotada e nela os sensores detectam
    paredes = obterParedes(maze_grid);

    % Polyshape espec√≠fica pra detectar colis√£o com mouse
    wall_polys = gerarParedesPolyshape(paredes);

    % figura da anima√ß√£o
    figure('Position', [820, 0, 700, 700]); % [left, bottom, width, height];
    ax = gca;
    hold on;

    % bizurando o floofill e contagem de passos do maze_grid
    floodval = flood_fill_micromouse(maze_grid, goal, 0, start);
    
    % plotando o mapa
    visualize_maze_bitfield(wall_polys,N ,goal, floodval,ax);

    % Melhor caminho at√© o goal, com celulas e comandos/direcoes delas
    [path,ordens] = stack_caminho(floodval,maze_grid,start);

    % Plotando mouse pela primeira vez

    % Polyshape do mouse, para  detectar colis√£o com parede
    poly_mouse = mousePolyshape(mouse.x_real, mouse.y_real, mouse.theta_real, mouse.side);
    h_mouse = plot(ax,poly_mouse, 'FaceColor', 'blue', 'FaceAlpha', 0.4); 
    % Plotar raio do sensor
    h_ray_f = plot(ax,[mouse.x_real mouse.x_real], [mouse.y_real mouse.y_real], 'r--'); % frente
    h_ray_d = plot(ax,[mouse.x_real mouse.x_real], [mouse.y_real mouse.y_real], 'b--'); % direita
    h_ray_e = plot(ax,[mouse.x_real mouse.x_real], [mouse.y_real mouse.y_real], 'g--'); % esquerda
    

    % Main Loop
    dt=0.01;
    t=0; %tempo inicial
    tic; 

    % Inicializa controlador h√≠brido
    ctrl = PIDlookahead();
    giro = PIDgiro();
    
    % Vetor que da boost ao robo quando ve varios comando de linha reta
    consecutivos = obterSequenciaOrdens(ordens);
    % Em qual trecho de consecutivos esta
    trecho=1;
    % quantas celulas do trecho total (curva) percorreu
    cellPercorridas=0;

    % Stack de celulas vira curva
    [xx, yy] = path_to_line(path,ordens, 1,ax);

    % colidiu ou n√£o
    colidiu = false;
    

    while ~isequal(mouse.cell, goal)

        % O boost tem seu pico no meio do trecho, acelerando e desacelerando
        if(trecho==1), anterior=consecutivos(trecho);
        else, anterior = consecutivos(trecho-1);
        end 
        boost = max(consecutivos(trecho)-cellPercorridas),1);

        % Chamando o PID
        dist_esq = sensorLeitura(mouse, paredes, 'esquerda');
        dist_dir = sensorLeitura(mouse, paredes, 'direita');
        dist_f=sensorLeitura(mouse, paredes, 'frente');

        [vR,vL, ctrl] = ctrl.update(mouse, xx, yy, dt, dist_esq,dist_dir,dist_f, boost);
        % velocidade angular das rodas (rad/s) -> pulsos acumulados
        [delta_pulsos_L,delta_pulsos_R] = encoder_simulado(mouse);
        
        % [2] Acumula nos encoders simulados
        mouse.encoder_L = mouse.encoder_L + delta_pulsos_L;
        mouse.encoder_R = mouse.encoder_R + delta_pulsos_R;
        % [3] Estima a velocidade angular da roda com base nos pulsos contados no intervalo
        mouse.wL_encoder = ((mouse.encoder_L - mouse.encoder_L_prev) * 2*pi) / mouse.pulsos_por_volta / dt;
        mouse.wR_encoder = ((mouse.encoder_R - mouse.encoder_R_prev) * 2*pi) / mouse.pulsos_por_volta / dt;
        
        % [4] Atualiza o valor anterior (para o pr√≥ximo delta)
        mouse.encoder_L_prev = mouse.encoder_L;
        mouse.encoder_R_prev = mouse.encoder_R;

        [mouse.wL_real, mouse.wR_real, giro]= giro.update(mouse, vR,vL,dt);
        

        % atualizando o Mickey
        mouse.vR_real=mouse.wR_real*mouse.wheel;
        mouse.vL_real=mouse.wL_real*mouse.wheel;
        mouse.vR_encoder=mouse.wR_encoder*mouse.wheel;
        mouse.vL_encoder=mouse.wL_encoder*mouse.wheel;
        curCell = returnCell(N,mouse);
        if ~isequal(curCell,mouse.cell), cellPercorridas=cellPercorridas+1;end
        if(cellPercorridas == consecutivos(trecho)), trecho = trecho+1;end
        mouse.cell=curCell;
        
        % Mexendo o mouse
        % --- CINEM√ÅTICA DIFERENCIAL  REAL ---
        v_media = (mouse.vR_real + mouse.vL_real) / 2;
        w_mouse = (mouse.vR_real - mouse.vL_real) / mouse.L;
        mouse.x_real = mouse.x_real + v_media * cos(mouse.theta_real) * dt;
        mouse.y_real = mouse.y_real + v_media * sin(mouse.theta_real) * dt;
        mouse.theta_real = mouse.theta_real + w_mouse * dt;
        mouse.theta_real = atan2(sin(mouse.theta_real), cos(mouse.theta_real));

        % --- CINEM√ÅTICA DIFERENCIAL  ENCODER ---
        v_media = (mouse.vR_encoder  + mouse.vL_encoder ) / 2;
        w_mouse = (mouse.vR_encoder  - mouse.vL_encoder ) / mouse.L;
        mouse.x_encoder = mouse.x_encoder + v_media * cos(mouse.theta_encoder ) * dt;
        mouse.y_encoder = mouse.y_encoder  + v_media * sin(mouse.theta_encoder ) * dt;
        mouse.theta_encoder  = mouse.theta_encoder  + w_mouse * dt;
        mouse.theta_encoder  = atan2(sin(mouse.theta_encoder ), cos(mouse.theta_encoder ));

        %um problema de cada vez
        mouse.x_encoder=mouse.x_real;
        mouse.y_encoder=mouse.y_real;
        mouse.theta_encoder=mouse.theta_real;

        % tempos de frame e da precis√£o simula√ß√£o
        t=t+1;
        
        if mod(t, 1) == 0
            % Visualize mouse
            poly_mouse = mousePolyshape(mouse.x_real, mouse.y_real, mouse.theta_real, mouse.side);
            h_mouse=visualize_mouse(poly_mouse,mouse,h_mouse);
            % Reta do sensor 
            visualize_ray(mouse,paredes,h_ray_f,h_ray_d,h_ray_e);
            % Debug
            fprintf("(x) e (y) e(theta) :%f,%f  %f \n",mouse.x_real,mouse.y_real,mouse.theta_real/pi*180);
            %fprintf("ENCODER: (x) e (y) e(theta) :%f,%f  %f \n",mouse.x_encoder,mouse.y_encoder,mouse.theta_encoder/pi*180);
            fprintf("Trecho, percorridas, boost : %.3f , %.1f, %f\n", trecho,cellPercorridas, boost);
            fprintf("ENCODER: (v) e (omega) :%f,%f  \n",(mouse.vR_encoder  + mouse.vL_encoder ) / 2, (mouse.vR_encoder  - mouse.vL_encoder ) / mouse.L);
            fprintf("Real: (v) e (omega) :%f,%f  \n",(mouse.vR_real  + mouse.vL_real ) / 2, (mouse.vR_real  - mouse.vL_real ) / mouse.L);
            fprintf("Giros comandados: \n R: %f \n L: %f \n",mouse.wR_real,mouse.wL_real);
            fprintf("Velocidades comandadas: \n v: %f \n w: %f \n",(vR + vL) / 2,(vR-vL)/(2*mouse.L));
        end
        
        if mod(t, 1/dt) == 0
            clc;
            fprintf("Tempo %.2f \n", t);
           
        end

        %for i = 1:length(wall_polys)
        %    if overlaps(poly_mouse, wall_polys(i))
        %        colidiu = true;
        %        break;
        %    end
        %end
        
        %if colidiu
        %    disp("üü• Colis√£o detectada! Encerrando simula√ß√£o...");
        %return; 
        %end
    end

    % Final visualization
    
    title(sprintf('Terminou em %f segundos!',toc));
end






